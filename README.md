<ul class="download">
	<li><a href="994276/WpfPixelShaderWorkbench-noexe.zip">Download source code in VB.NET (VS2015) - 5.5 MB</a></li>
	<li><a href="WpfPixelShaderWorkbench.zip">Download source code and demo in VB.NET (VS 2015) - 5.5 MB</a></li>
</ul>

<p><img src="ScreeShot.gif" style="width: 500px; height: 226px;" /></p>

<h2>Introduction</h2>

<p>If you have used Effects in WPF before, you have inadvertently also (hopefully) used GPU accelerated functions in WPF. These affects are called ShaderEffects and were introduced with the relese of .NET3.5SP1 (The old class BitmapEffects was obsolite from <a href="https://msdn.microsoft.com/en-us/library/ms743435%28v=vs.110%29.aspx">.NET 4.0</a>, so don&#39;t use them). Prior to that, the Effects were done in the CPU, causing serious performance issues on computer intensive effects, like blur. Now WPF offers Effects that have all the calculation done in the GPU, so visual effects does not affect your CPU performance. The downside is that WPF only offer two effects in the class <a href="http://https://msdn.microsoft.com/en-us/library/System.Windows.Media.Effects(v=vs.110).aspx">Media.Effects</a> (the old BitmapEffects are obsolete, and should NEVER be used):</p>

<ul>
	<li>Blur Effect</li>
	<li>DropShadowEffect</li>
</ul>

<p>WPF also offers something quite interesting, namely a <a href="https://msdn.microsoft.com/en-us/library/system.windows.media.effects.shadereffect(v=vs.110).aspx">ShaderEffect</a> class, and this is the class you can use ito communicate with custom created ShaderEffects. &nbsp;These effect files, *.ps, are generated by the DirectX compiler from *.fx (HLSL) files. This article will go these steps:</p>

<ul>
	<li>Writing you own HLSL (.fx) file</li>
	<li>How to compile the file into .ps (Pixel shader byte code)</li>
	<li>Set up a class in either VB.NET or C# in WPF to communicate with the .ps file</li>
	<li>Apply the effect to any WPF UIElement</li>
</ul>

<p>If you read through this article my hope is that you will gain the ability to create your own custom pixel shader file and use it in your own WPF application. I should mention that most of the Shader files on the internet uses the shaders in the Silverlight language, but this article will only focus on WPF usages, but will contain material from programs original written using Silverlight and shaders.</p>

<p>This article relies heavily on the knowledge learned from reading the source code for Walt Ritscher for his program&nbsp;<a href="https://shazzam.codeplex.com/">Shazzam Tool</a>, and with the basis in his code I made some changes and improvements as his tool didn&#39;t run properly for me. Since the tool first was published there has also been some changes, especially on the Windows operation system, as the DirectX compiler and DLL&#39;s are now included by default.&nbsp;</p>

<p>If you have a bought version of Visual Studio 2013 or above you could use the built in&nbsp;<a href="https://msdn.microsoft.com/en-us/library/hh315751.aspx">graphics debugger</a>&nbsp;instead. This article is mainly written for Visual Studio Express users, allowing user to write fx files with Visual Studio highlight the HLSL, although you might pick up some hints and tips on the usage of pixel shaders.&nbsp;</p>

<h2>Generating HLSL files</h2>

<p>The fx files or <a href="https://msdn.microsoft.com/en-us/library/windows/desktop/bb509561(v=vs.85).aspx">HLSL</a>&nbsp;(an abbreviation&nbsp;for High Level Shading Language) files as they also are called. The files are programmed using a C like language, with a very limited number of functions that you can use. This makes it rather fast to learn and easy to use, but it do have some quirky details.</p>

<p>The fx files that are used by the ShaderEffect class in WPF always begin with a series of registered values that are stored in the GPU which you can <a href="https://msdn.microsoft.com/en-us/library/windows/desktop/dd607359(v=vs.85).aspx">communicate</a> with using the ShaderEffect class (However, if you use the lib file in C++ you can access all of them). You can now see that the number of inputs that are availiable are fairly limited, there is also a maximum on how many you can use.&nbsp;</p>

<p>https://msdn.microsoft.com/en-us/library/hh315751(v=vs.110).aspx</p>

<p>In the PixelShaders used in WPF this line of code below has to be included in the fx file. Its were the Image itself is stored in the GPU register, and the pointer to where it can be reached.</p>

<pre lang="C++">
 
sampler2D Input : register(S0);</pre>

<p>This line of code actually specifies that the sampler2D value Input should be stored in the GPU register. It also specify in what register type it is in (S) but there are many more <a href="https://msdn.microsoft.com/en-us/library/windows/desktop/dd607359(v=vs.85).aspx">available</a>, but the WPF application written in C# and VB can only communicate with the S and C register values.&nbsp;</p>

<p>In the Pixel Shader you work on one Pixel at the time, and in the main the function call (entry point of the ps file), you get as an input the current pixel location in x and y coordinates. Well that not quite true, you do get the coordinates but they are between 0 to 1 (0,0 are upper left corner), that is why its a float2 variable.</p>

<pre lang="C++">
 
float4 main(float2 uv : TEXCOORD) : COLOR
{
 ...
}</pre>

<p>you get the 4 values for the color of the given pixel by using the tex2 function, and the color is stored in a 4 item vector with float (again with values form 0 &nbsp;to 1, instead of the normal byte from 0 to 255) precision using the float4 deliberative field:</p>

<pre lang="C++">
 
   float4 color = tex2D( Input, uv );</pre>

<p>And to, let&#39;s say, invert the colors of the image, we simply add the line:</p>

<pre lang="C++">
 
    float4 inverted_color = 1 - color ;</pre>

<p lang="text">And to avoid the alpha (transparency factor) to be changed (<a href="https://msdn.microsoft.com/en-us/library/windows/desktop/bb509634(v=vs.85).aspx">there are more ways of getting the value</a>), and &nbsp;to return the inverted color.:&nbsp; &nbsp;</p>

<pre lang="text">
 
    inverted_color.a = 1; 
    return inverted_color;</pre>

<p>This knowledge allows you to create all the effects that is calculated by one single pixel at the time. But most of the interesting stuff on images involves getting the neighboring pixels as well. Effects like a Gaussian filer, Sobel Filter etc all require calculations being done of several Neighboring pixels, so we need this function (the edge detector use a version of the derivative, which is actually available on the GPU as a <a href="https://msdn.microsoft.com/en-us/library/system.windows.media.effects.shadereffect.ddxuvddyuvregisterindex(v=vs.110).aspx">function</a>):</p>

<pre lang="C++">
 
float4 GetNeighborPixel(float2 uv, float2 pixelOffset)
{
    float x = pixelOffset.x / InputSize.x;
    float y = pixelOffset.y / InputSize.y;
    float2 NeighborPoint = { uv.x + x, uv.y + y };        
    return  tex2D(input, NeighborPoint);
};</pre>

<p>There is one thing that is special about functions in the fx files, <a href="http://stackoverflow.com/questions/11814087/hlsl-function-is-not-being-recognized-undeclared-error">that is</a>; each function must be declared before it is used:</p>

<pre lang="C++">
 
float TestFunc(float n)
{
     // ...
}

float main()
{
    // ...
}</pre>

<p>or have a pointer declared before its used:</p>

<pre lang="C++">
 
float TestFunc(float);

float main()
{
    // ...
}

float TestFunc(float n)
{
    // ...
}</pre>

<p>Assuming all is well, and you have defined the function properly, you should realize that you need the actual size of the picture. Since all the coordinates are on double precision format from 0 to 1, a pixel step is in double format.</p>

<pre lang="C++">
 
/// &lt;summary&gt;Explain the purpose of this variable.&lt;/summary&gt;
/// &lt;minValue&gt;1, 1&lt;/minValue&gt;
/// &lt;maxValue&gt;1024, 1024&lt;/maxValue&gt;
/// &lt;defaultValue&gt;599, 124&lt;/defaultValue&gt;
float2 InputSize : register(C0);  </pre>

<p>In reality, you should now be able to write any PixelShader you want, just glace over the available functions from the <a href="https://msdn.microsoft.com/en-us/library/windows/desktop/ff471376(v=vs.85).aspx">documentation</a>. Some cool example, that are pretty straight forward to follow, by <a href="http://www.codeproject.com/Members/TamirKhason">Tamir Khason</a> can be seen in these two links below:</p>

<ul>
	<li><a href="http://blogs.microsoft.co.il/tamir/2008/05/23/brightness-and-contrast-manipulation-in-wpf-35-sp1/">http://blogs.microsoft.co.il/tamir/2008/05/23/brightness-and-contrast-manipulation-in-wpf-35-sp1/</a></li>
	<li><a href="http://blogs.microsoft.co.il/tamir/2008/06/17/hlsl-pixel-shader-effects-tutorial/">http://blogs.microsoft.co.il/tamir/2008/06/17/hlsl-pixel-shader-effects-tutorial/</a></li>
</ul>

<p>There are also some old legacy tools for creating cool effects that might be worth taking a look at:</p>

<ul>
	<li><a href="https://developer.nvidia.com/fx-composer">Fx-composer</a></li>
	<li><a href="http://developer.amd.com/tools-and-sdks/archive/legacy-cpu-gpu-tools/rendermonkey-toolsuite/">Rendermonkey</a></li>
	<li><a href="http://developer.amd.com/tools-and-sdks/graphics-development/gpu-perfstudio/">PerfStudio</a></li>
</ul>

<p>For more advanced shaders you might even want to use&nbsp;<a href="http://code4k.blogspot.no/2011/11/advanced-hlsl-using-closures-and.html">functions and class like structures</a>&nbsp;in order to effectively program it. While the functions used are very useful for complex effects, you might need to compile the shader with a higher version than the standard version of 2.0 or 3.0.</p>

<h2>Compiling HLSL files</h2>

<p>Before I start to explain how to compile the fx files, I&#39;d just want to say that this is only really needed if you have the <a href="https://msdn.microsoft.com/en-us/library/vstudio/hh315751(v=vs.110).aspx">Express editions</a> of <a href="http://blogs.msdn.com/b/chuckw/archive/2012/05/07/hlsl-fxc-and-d3dcompile.aspx">Visual Studio</a> (of either 2012, &nbsp;2013 or 2015), in the version you buy, you get to compiler as a resource. In the VS 2010 there is also a tool for compiling the fx file as a resource using a codeplex plugin. However, I think it would be useful to read the section anyway. I should also mention that there is yet another option to compile the fx file in VS 2010 and 2008 by installing a <a href="http://wpf.codeplex.com/releases/view/14962">add-in</a> to Visual Studio&nbsp;</p>

<h4>Using the fxc to compile</h4>

<p>In previous Windows versions you needed to install the DirectX SDK in order to get the fxc.exe file that is needed to compile the fx files into machine codeed ps. From <a href="https://msdn.microsoft.com/library/windows/desktop/ee663275.aspx">Windows 8 the SDK is deployed as standard</a>, saving you several hundred MB download (although the fxc file, the only one you really need, is only about 250KB.).</p>

<p>To compile the fx file most seem to do a quick compile using the build event in VS 2013. The compilation (on Windows 8.1) would be the following in the post build command:</p>

<pre lang="text">
 
&quot;C:\Program Files\Windows Kits\8.1\bin\x86\fxc.exe&quot; /T ps_2_0 /E main /Fo&quot;Watercolor.ps&quot; &quot;Watercolor.fx&quot;</pre>

<p>But as it turned out, the <a href="https://msdn.microsoft.com/en-us/library/7xctbe2f.aspx">build event</a>, isn&#39;t availiable in <a href="http://stackoverflow.com/questions/25708133/impossible-to-compile-hlsl-shaders-after-updating-to-sharpdx-2-6-2">VB.NET</a>! Well, that wouldn&#39;t have to be a problem, I would just have to build it in the Application.XAML file. However you must remember to implement the namespace in your application to accssess classes you have there:</p>

<pre lang="vb.net">
 
Imports WpfAdventuresInPixelShader

Class Application

    &#39; Application-level events, such as Startup, Exit, and DispatcherUnhandledException
    &#39; can be handled in this file.

    Public Sub New()
      &#39; My code to build the fx files goes here...  
    End Sub  

End Class</pre>

<p>Having this hurdle made me go into the details of how an fx file is compiled a lot earlier than I thought, and I quickly found out one critical issue. If you open the fx file in VS (any year really), it stores the text in UTM-8 by default. The funny, or not so funny depending one once perspective is that it wont compile it if it is not in the notepad ANSI code or the ASCII code. This was actually so annoying that I decided to open the file and store it using the ASCII encoding:</p>

<pre lang="vb.net">
 
        &#39; Making sure the fx files are stored in an encoding
        &#39; that fxc understands. (It does not understand the default Visual studio encoding!)
        For Each file As String In directoryEntries

            &#39;Open the .fx file
            Dim OpenFxFileInTextFormat() As String = IO.File.ReadAllLines(file)

            &#39;Makeign sure its stored in a format that the fxc compiler understands
            IO.File.WriteAllLines(file, OpenFxFileInTextFormat, Text.Encoding.ASCII)
        Next</pre>

<p>This little code snippet enabled me to write and edit files directly in the VS 2013 and still use the small fxc.exe compiler (There are other ways of achieving this by importing a DLL file to compile it in code, more on that later.). There is one more thing that you could do. If you run this code the VS 2013 compiler will detect changes in the file and will ask you if you want to reload it. So to save yourself some trouble, in the top menu go to:</p>

<p>TOOLS-&gt;OPTIONS...</p>

<p>A dialog will appear where you navigate to&nbsp;</p>

<p>Environment-&gt;Documents</p>

<p>Tick off the Auto-Load changes, if saved here:</p>

<p><img src="AutoLoadOnChanges.gif" style="width: 500px; height: 300px;" /></p>

<p>I assume that you will have all the uncompiled fx files added as a resource in a folder, and that you want the compiled files to be contained in a folder where your exe file is compiled at. So I did the following:</p>

<pre lang="vb.net">
 
&#39;Get the folder where the exe file is currently compiled
        Dim ExeFileDirectory As String = AppDomain.CurrentDomain.BaseDirectory

        &#39;The name of the folder that will be opened or created at the exe folder location
        Dim FolderNameForTheCompiledPsFiles As String = &quot;ShaderFiles&quot;

        &#39; Create the Directory were the shader files will be
        Dim FolderWithCompiledShaderFiles As String = ExeFileDirectory &amp; FolderNameForTheCompiledPsFiles

        &#39; If it dosn&#39;t exitst creat it
        If (Not IO.Directory.Exists(FolderWithCompiledShaderFiles)) Then
            IO.Directory.CreateDirectory(FolderWithCompiledShaderFiles)
        End If

        &#39;Find the resource folder where the uncompiled fx filer are
        Dim ShaderSourceFiles As String = IO.Path.Combine(GetParentDirectory(ExeFileDirectory, 2), &quot;ShaderSourceFiles&quot;)

        &#39; Get all the uncopiled files in the folder
        Dim directoryEntries As String() = System.IO.Directory.GetFileSystemEntries(ShaderSourceFiles, &quot;*.fx&quot;)</pre>

<p>In the normal debug mode, the exe file is stored in a folder c:\ ... YouProject\bin\debug\YourExeFile.Exe so you need to back up two directories to get to the folder where the resource folder is located at. So I mad a short little function:</p>

<pre lang="vb.net">
 
    Private Function GetParentDirectory(ByVal FolderName As String, Optional ByVal ParentNumber As Integer = 1) As String

        If ParentNumber = 0 Then
            Return FolderName
        End If

        Dim result As IO.DirectoryInfo
        Dim CurrentFolderName As String = FolderName
        For i As Integer = 1 To ParentNumber + 1
            result = IO.Directory.GetParent(CurrentFolderName)
            CurrentFolderName = result.FullName
        Next
        Return CurrentFolderName
    End Function</pre>

<p>Now that we got the desired folders, one folder where we get the fx files and another where we will place the compiled files in. I decided to make two classes, one that hold the specific fx file properties and compilation settings for the file, and one that would do all the compiler stuff. Below is an exert from the HLSLFileHelperClass:</p>

<pre lang="vb.net">
 
Public Class HLSLFileHelperClass

    ...

    Private pFileNameWithoutExtension As String
    Public Property FileNameWithoutExtension() As String
        Get
            Return pFileNameWithoutExtension
        End Get
        Set(ByVal value As String)
            pFileNameWithoutExtension = value
        End Set
    End Property

    ...

    Private pHLSLEntryPoint As String = &quot;main&quot;
    Public Property HLSLEntryPoint() As String
        Get
            Return pHLSLEntryPoint
        End Get
        Set(ByVal value As String)
            pHLSLEntryPoint = value
        End Set
    End Property

    Private pShaderCompilerVersion As ShaderVersion = ShaderVersion.ps_3_0
    Public Property ShaderCompilerVersion() As ShaderVersion
        Get
            Return pShaderCompilerVersion
        End Get
        Set(ByVal value As ShaderVersion)
            pShaderCompilerVersion = value
        End Set
    End Property

    Public Enum ShaderVersion
        ps_2_0
        ps_3_0
        ps_4_0
        ps_4_1
        ps_5_0
    End Enum


End Class</pre>

<p>The Compiler helper would then hold a list of <code>HLSLFileHelperClass</code>&nbsp;that was going to be compiled, and the actual methods for the compiling. The compiler is done in a hidden cmd.exe window:</p>

<pre lang="vb.net">
 
    Sub Compile()
        Dim p As New Process()
        Dim info As New ProcessStartInfo()
        info.FileName = &quot;cmd.exe&quot;
        info.CreateNoWindow = True
        info.WindowStyle = ProcessWindowStyle.Hidden
        info.RedirectStandardInput = True
        info.UseShellExecute = False
        info.RedirectStandardOutput = True
        info.RedirectStandardError = True

        p.StartInfo = info

        p.Start()
        p.BeginOutputReadLine()
        p.BeginErrorReadLine()

        AddHandler p.OutputDataReceived, AddressOf NormalOutputHandler
        AddHandler p.ErrorDataReceived, AddressOf ErrorAndWarningOutputHandler

        Dim sw As IO.StreamWriter = p.StandardInput

        Dim result As String = &quot;&quot;
        For Each File As HLSLFileHelperClass In FilesToCompile
            CompileFile(sw, File)
        Next

        p.WaitForExit(1000)
    End Sub</pre>

<p>The error, warnings and compile completed messages are collected by the two handlers, and the information is stored in a String property that implements <code>INotifiedChange</code> interface.The CompileFile class just connects the necessary information and runs the command in cmd:</p>

<pre lang="vb.net">
 
    Sub CompileFile(ByVal sw As IO.StreamWriter, ByVal sender As HLSLFileHelperClass)
        If sw.BaseStream.CanWrite Then
            Dim s As String = &quot;&quot;&quot;&quot; &amp; FXCFileLocation &amp; &quot;&quot;&quot; /T &quot; &amp; sender.ShaderCompilerVersion.ToString &amp; &quot; /E &quot; &amp; sender.HLSLEntryPoint &amp; &quot; /Fo&quot;&quot;&quot; &amp; sender.GetCompiledFileFullName &amp; &quot;&quot;&quot; &quot;&quot;&quot; &amp; sender.GetSourceFileFullName &amp; &quot;&quot;&quot;&quot;
            sw.WriteLine(s)
        End If
    End Sub</pre>

<p>The different attributes in the command line is explained in the table below:</p>

<table border="1" cellpadding="1" cellspacing="1" class="grid" style="width: 500px;">
	<tbody>
		<tr>
			<td style="width: 100px; background-color: rgb(102, 255, 255);">Attribute</td>
			<td style="width: 300px; background-color: rgb(102, 255, 255);">Description</td>
		</tr>
		<tr>
			<td>/T</td>
			<td><a href="https://msdn.microsoft.com/en-us/library/windows/desktop/jj215820.aspx">Shader profile</a> that will be used in compiling the file. ps_2_0 is simply Shader 2.0.</td>
		</tr>
		<tr>
			<td>/E</td>
			<td>the entery function in the shader, like the console programs in the old days started with void main</td>
		</tr>
		<tr>
			<td>/Fo</td>
			<td>the name and location of the file that is produced by the compiler (File Out)</td>
		</tr>
	</tbody>
</table>

<p>These three are simply the must have to compile the file, but there are many more settings <a href="https://msdn.microsoft.com/en-us/library/windows/desktop/bb509709(v=vs.85).aspx">available</a>.</p>

<p>I now have the equivalent to the build event, that is actually a bit better than it. It will run the compiler before the MainWindow starts, and you can bind the compiler results (either just have the error and warnings of all the compiled files, or the complete build store that will tell you if the file was compiled or not.) Lets face it, if you are a normal person, you will need the error massage sooner or later. The error (or warning!) will be given with a error code example: X3123, and the text that will follow is the corresponding to the list <a href="https://msdn.microsoft.com/en-us/library/windows/desktop/dn508414%28v=vs.85%29.aspx">here</a>. And lastly, it will give you the line number where the error or warning was thrown.</p>

<h4>Using DLL&#39;s to compile the fx file</h4>

<p>The fxc file compiler is not that bad, but it requires quite a lot of command line code and you would have to convert the file to ANSI format before you can compile the files. Both of these nusiances can be avoided if you instead compile the fx with an unmanaged (c++ compiled) dll call.&nbsp;</p>

<p>Before I go one here I&#39;m going to have to explain something first. The actual dll (32 bit system that is) file that has this function is located (on Windows 8.0, 8.1 and 10, just exchange the 10 with 8.1 or 8.1 to get the appropriate path for your version) here:</p>

<p>C:\Program Files\Windows Kits\10\bin\x86</p>

<p>If you have a keen eye, you will see that this is the same place that the fxc.exe file is located. However, if you wish to include a DLL in your program make sure to use the files that are meant for redistribution and are found here (for 32 bit again):</p>

<p>C:\Program Files\Windows Kits\10\Redist\D3D\x86</p>

<p>There could be differences on the two files, as one might be tailor made to fit your hardware. If you have any other versions of Windows you might want to have a look at this Codeproject article. It explains various ways of adding the DLL as a resource in a Visual studio project:</p>

<ul>
	<li><a href="http://www.codeproject.com/Articles/528178/Load-DLL-From-Embedded-Resource">Load DLL From Embedded Resource</a></li>
</ul>

<p>I decided to go an even easier way of to specify what DLL to use, as suggested by <a href="http://blogs.msdn.com/b/jonathanswift/archive/2006/10/03/dynamically-calling-an-unmanaged-dll-from-.net-_2800_c_23002900_.aspx">Jonathan Swift</a>&nbsp;by employing <a href="https://msdn.microsoft.com/en-us/library/windows/desktop/ms684175(v=vs.85).aspx">LoadLibrary</a> from the kernel32.dll:</p>

<pre lang="vb.net">
 
Imports System.Runtime.InteropServices

Module NativeDLLMethods
    &lt;DllImport(&quot;kernel32.dll&quot;)&gt;
    Public Function LoadLibrary(dllToLoad As String) As IntPtr
    End Function

    &lt;DllImport(&quot;kernel32.dll&quot;)&gt;
    Public Function GetProcAddress(hModule As IntPtr, procedureName As String) As IntPtr
    End Function

    &lt;DllImport(&quot;kernel32.dll&quot;)&gt;
    Public Function FreeLibrary(hModule As IntPtr) As Boolean
    End Function
End Module</pre>

<p>You can now load the DLL into memory, we will now take a closer look at how to implement the unmanaged code in C# or VB.NET. In the <a href="https://msdn.microsoft.com/en-us/library/windows/desktop/dd607324(v=vs.85).aspx">documentation</a> the parameters for loading the DLL is given:</p>

<pre lang="C++">
 
HRESULT WINAPI D3DCompileFromFile(
  in      LPCWSTR pFileName,
  in_opt  const D3D_SHADER_MACRO pDefines,
  in_opt  ID3DInclude pInclude,
  in      LPCSTR pEntrypoint,
  in      LPCSTR pTarget,
  in      UINT Flags1,
  in      UINT Flags2,
  out     ID3DBlob ppCode,
  out_opt ID3DBlob ppErrorMsgs
);</pre>

<p>When you define the entry point of the DLL, be sure to read the input types carefully, the <a href="https://msdn.microsoft.com/en-us/library/s9ts558h%28v=vs.110%29.aspx">strings especially</a>. They have several different types of marshal. The Definition that finally worked looked like this:</p>

<pre lang="vb.net">
 
    &lt;DllImport(&quot;d3dcompiler_47.dll&quot;, CharSet:=CharSet.Auto)&gt; _
    Public Function D3DCompileFromFile(&lt;MarshalAs(UnmanagedType.LPWStr)&gt; pFilename As String,
                                                          pDefines As IntPtr,
                                                          pInclude As IntPtr,
                                                          &lt;MarshalAs(UnmanagedType.LPStr)&gt; pEntrypoint As String,
                                                          &lt;MarshalAs(UnmanagedType.LPStr)&gt; pTarget As String,
                                                          flags1 As Integer,
                                                          flags2 As Integer,
                                                          ByRef ppCode As ID3DBlob,
                                                          ByRef ppErrorMsgs As ID3DBlob) As Integer</pre>

<p>The two last elements , one that returns the compiled code and another that returns the possible error messages. It is given the name ID3DBlob, and its defined in the <a href="https://msdn.microsoft.com/en-us/library/windows/desktop/ff728743(v=vs.85).aspx">documentation</a>. You also need the <a href="http://blogs.msdn.com/b/adam_nathan/archive/2003/04/30/56646.aspx">PreserveSig</a> in this section, otherwise it wont work (The <a href="https://msdn.microsoft.com/en-us/library/system.runtime.interopservices.dllimportattribute.preservesig(v=vs.110).aspx">documentation</a>).</p>

<pre lang="vb.net">
 
    &lt;Guid(&quot;8BA5FB08-5195-40e2-AC58-0D989C3A0102&quot;), InterfaceType(ComInterfaceType.InterfaceIsIUnknown)&gt; _
    Public Interface ID3DBlob
        &lt;PreserveSig&gt; _
        Function GetBufferPointer() As IntPtr
        &lt;PreserveSig&gt; _
        Function GetBufferSize() As Integer
    End Interface</pre>

<p>We now have all the code necessary for compiling the fx files with the DLL file instead of the tedious and complicated use of the fxc.exe file. The code blocks above that defined the dll function could be used as it is if you have Windows 8.0 or higher, as the location is known to the system.</p>

<p>To make sure that it will work on older versions of Windows, we need to specify the location and file we want to use. But to use the LoadLibrary function you need to define a delegate (that functions as a C++ style a pointer in this case) to define the function call you want to call within the DLL:</p>

<pre lang="vb.net">
 
Imports System.Runtime.InteropServices

Module DLLForLoadLibraryUse

    Public Delegate Function D3DCompileFromFile(&lt;MarshalAs(UnmanagedType.LPWStr)&gt; pFilename As String,
                                                          pDefines As IntPtr,
                                                          pInclude As IntPtr,
                                                          &lt;MarshalAs(UnmanagedType.LPStr)&gt; pEntrypoint As String,
                                                          &lt;MarshalAs(UnmanagedType.LPStr)&gt; pTarget As String,
                                                          flags1 As Integer,
                                                          flags2 As Integer,
                                                          ByRef ppCode As ID3DBlob,
                                                          ByRef ppErrorMsgs As ID3DBlob) As Integer

    Public Delegate Function D3DCompile(&lt;MarshalAs(UnmanagedType.LPStr)&gt; pSrcData As String,
                                                         SrcDataSize As Integer,
                                                        &lt;MarshalAs(UnmanagedType.LPStr)&gt; pSourceName As String,
                                                         pDefines As IntPtr,
                                                         pInclude As IntPtr,
                                                        &lt;MarshalAs(UnmanagedType.LPStr)&gt; pEntrypoint As String,
                                                        &lt;MarshalAs(UnmanagedType.LPStr)&gt; pTarget As String,
                                                         flags1 As Integer,
                                                         flags2 As Integer,
                                                        ByRef ppCode As ID3DBlob,
                                                        ByRef ppErrorMsgs As ID3DBlob) As Integer

End Module</pre>

<p>In the origianl post from Jonathan swift he recommended to use this <a href="https://msdn.microsoft.com/en-us/library/system.runtime.interopservices.callingconvention.aspx">calling convention</a> line above the delegate:</p>

<pre lang="vb.net">
&lt;UnmanagedFunctionPointer(CallingConvention.Cdecl)&gt;</pre>

<p>It is only nessecery to use that if the function call contains a varargs, in fact; if you include this in the compiler for fx files it would give you an error, saying that the number of parameters in the delegate mismatch the numbers in the DLL function call. In fact <a href="http://blogs.msdn.com/b/jonathanswift/archive/2006/10/03/dynamically-calling-an-unmanaged-dll-from-.net-_2800_c_23002900_.aspx#10021596">Martin Costello</a> suggest using the function call:</p>

<pre lang="vb.net">
&lt;UnmanagedFunctionPointer(CallingConvention.StdCall)&gt;</pre>

<p>It is not nessesary to include this line, as it is the default calling conavention.&nbsp;</p>

<p>Since the DLL only needs to be loaded once, I decided to use shared variables to hold pointers to the position in memory.&nbsp;</p>

<pre lang="vb.net">
    Public Shared FxDllCompiler As IntPtr
    Public Shared pAddressOfFxByteCompiler As IntPtr
    Public Shared pAddressOfFxBFileompiler As IntPtr
    Public Shared pFxByteStreamCompilation As DLLForLoadLibraryUse.D3DCompile
    Public Shared pFxFileCompilation As DLLForLoadLibraryUse.D3DCompileFromFile

    Public Shared DllFilesLocation As String

    Public Shared Sub FreeDlls()
        Dim result As Boolean = NativeDLLMethods.FreeLibrary(FxDllCompiler)
    End Sub

    Public Shared Sub SetUpDlls()

        If IntPtr.Size = 4 Then
            FxDllCompiler = NativeDLLMethods.LoadLibrary(IO.Path.Combine(DllFilesLocation, &quot;d3dcompiler_47_32bit.dll&quot;))
        Else
            FxDllCompiler = NativeDLLMethods.LoadLibrary(IO.Path.Combine(DllFilesLocation, &quot;d3dcompiler_47_64bit.dll&quot;))
        End If

        If FxDllCompiler = IntPtr.Zero Then
            MessageBox.Show(&quot;Could not load the DLL file&quot;)
        End If

        pAddressOfFxByteCompiler = NativeDLLMethods.GetProcAddress(FxDllCompiler, &quot;D3DCompile&quot;)
        If pAddressOfFxByteCompiler = IntPtr.Zero Then
            MessageBox.Show(&quot;Could not locate the function D3DCompile in the DLL&quot;)
        End If

        pAddressOfFxBFileompiler = NativeDLLMethods.GetProcAddress(FxDllCompiler, &quot;D3DCompileFromFile&quot;)
        If pAddressOfFxBFileompiler = IntPtr.Zero Then
            MessageBox.Show(&quot;Could not locate the function D3DCompileFromFile in the DLL&quot;)
        End If

        pFxByteStreamCompilation = Marshal.GetDelegateForFunctionPointer(pAddressOfFxByteCompiler, GetType(DLLForLoadLibraryUse.D3DCompile))
        pFxFileCompilation = Marshal.GetDelegateForFunctionPointer(pAddressOfFxBFileompiler, GetType(DLLForLoadLibraryUse.D3DCompileFromFile))
    End Sub</pre>

<p>All the entries are stored as shared members, as I only need to load the functions into memory once, and use this as an entry point for further calls. I can also call FreeLibary after I have finished calling the method, but I don&#39;t, so the DLL&#39;s get released from memory once the application is terminated. You should be careful not to call <a href="https://msdn.microsoft.com/en-us/library/windows/desktop/ms683152(v=vs.85).aspx">FreeLibrary </a>if you arn&#39;t <a href="http://blogs.msdn.com/b/robgruen/archive/2004/11/12/256199.aspx">finished using the function</a>, as it will throw an error if you try to relese it after each call. Mike Stall has created a wrapper for unmanaged calls to the <code>kernel32.dll</code> <a href="http://blogs.msdn.com/b/jmstall/archive/2007/01/06/typesafe-getprocaddress.aspx">here</a> that you could use instead.</p>

<p>The Entry point of the DLL&#39;s are kept in a module, so it has only one point to start it from. The compile code for a file is thereby given as:</p>

<pre lang="vb.net">
    Public Sub Compile(ByVal File As HLSLFileHelperClass)
        Dim pFilename As String = File.GetSourceFileFullName
        Dim pDefines As IntPtr = IntPtr.Zero
        Dim pInclude As IntPtr = IntPtr.Zero

        Dim pEntrypoint As String = File.HLSLEntryPoint
        Dim pTarget As String = File.ShaderCompilerVersion.ToString

        Dim flags1 As Integer = 0
        Dim flags2 As Integer = 0
        Dim ppCode As DLLEntryPointModule.ID3DBlob = Nothing
        Dim ppErrorMsgs As DLLEntryPointModule.ID3DBlob = Nothing

        Dim CompileResult As Integer = 0

        CompileResult = DLLEntryPointModule.D3DCompileFromFile(pFilename,
                                           pDefines,
                                           pInclude,
                                           pEntrypoint,
                                           pTarget,
                                           flags1,
                                           flags2,
                                           ppCode,
                                           ppErrorMsgs)

        If CompileResult &lt;&gt; 0 Then
            Dim errors As IntPtr = ppErrorMsgs.GetBufferPointer()
            Dim size As Integer = ppErrorMsgs.GetBufferSize()

            ErrorText = Marshal.PtrToStringAnsi(errors)

            IsCompiled = False
        Else

            IsCompiled = True
            Dim psPath = File.GetCompiledFileFullName
            Dim pCompiledPs As IntPtr = ppCode.GetBufferPointer()
            Dim compiledPsSize As Integer = ppCode.GetBufferSize()

            Dim compiledPs = New Byte(compiledPsSize - 1) {}
            Marshal.Copy(pCompiledPs, compiledPs, 0, compiledPs.Length)
            Using psFile = IO.File.Open(psPath, FileMode.Create, FileAccess.Write)
                psFile.Write(compiledPs, 0, compiledPs.Length)
            End Using
        End If

        If ppCode IsNot Nothing Then
            Marshal.ReleaseComObject(ppCode)
        End If
        ppCode = Nothing

        If ppErrorMsgs IsNot Nothing Then
            Marshal.ReleaseComObject(ppErrorMsgs)
        End If
        ppErrorMsgs = Nothing
    End Sub</pre>

<p>There is also one more advantage with compiling from this DLL, the files does not have to be in ANSI format, so you can edit the files directly in Visual Studio and you don&#39;t have to worry about the file format any more.&nbsp;</p>

<pre lang="C++">
 
HRESULT WINAPI D3DCompile(
  in      LPCVOID pSrcData,
  in      SIZE_T SrcDataSize,
  in_opt  LPCSTR pSourceName,
  in_opt  const D3D_SHADER_MACRO pDefines,
  in_opt  ID3DInclude pInclude,
  in      LPCSTR pEntrypoint,
  in      LPCSTR pTarget,
  in      UINT Flags1,
  in      UINT Flags2,
  out     ID3DBlob ppCode,
  out_opt ID3DBlob ppErrorMsgs
);</pre>

<p>The code is nearly exactly the same as CompileFromFile code, the only difference is how the data is read in:</p>

<pre lang="vb.net">
 
        Dim s As String = IO.File.ReadAllText(file.GetSourceFileFullName)

        Dim pSrcData As String = s
        Dim SrcDataSize As Integer = s.Length</pre>

<h2>Interact with *.ps files in VB.NET/C#</h2>

<p>The simplest way that you have for a class to interacts with the values in the ps file, is to inherit the <a href="https://msdn.microsoft.com/en-us/library/system.windows.media.effects.shadereffect_methods(v=vs.110).aspx">ShaderEffect</a> class. When you use the ShaderEffect class in WPF you only get to communicate with two types of registers (S and C). However they can hold a number of different types, and they don&#39;t exactly correspond, in name type, that is. The list of type in HLSL and the correspondent values in .NET are listed below (from <a href="http://mrpfister.com/journal/writing-hlsl-pixel-shaders-for-wpf/">this</a> site):</p>

<table border="1" cellpadding="1" cellspacing="1" style="width: 500px;">
	<tbody>
		<tr>
			<td>
			<table style="box-sizing: border-box; word-wrap: break-word; margin-removed 1em; margin-removed 1em; outline: 0px; font-size: 12px; vertical-align: baseline; border-collapse: collapse; border-spacing: 0px; color: rgb(68, 68, 68); font-family: 'Open Sans'; line-height: 18px; background: rgb(255, 255, 255);">
				<thead style="box-sizing: border-box; word-wrap: break-word; outline: 0px; vertical-align: baseline; background: transparent;">
					<tr style="box-sizing: border-box; word-wrap: break-word; outline: 0px; font-size: 12px; vertical-align: baseline; background: transparent;">
						<td style="box-sizing: border-box; word-wrap: break-word; padding: 6px; border: 1px solid rgb(204, 204, 204); outline: 0px; font-size: 12px; vertical-align: baseline; background: transparent;"><strong style="box-sizing: border-box; word-wrap: break-word; outline: 0px; vertical-align: baseline; background: transparent;">.NET type</strong></td>
						<td style="box-sizing: border-box; word-wrap: break-word; padding: 6px; border: 1px solid rgb(204, 204, 204); outline: 0px; font-size: 12px; vertical-align: baseline; background: transparent;"><strong style="box-sizing: border-box; word-wrap: break-word; outline: 0px; vertical-align: baseline; background: transparent;">HLSL type</strong></td>
					</tr>
				</thead>
				<tbody style="box-sizing: border-box; word-wrap: break-word; outline: 0px; vertical-align: baseline; background: transparent;">
					<tr style="box-sizing: border-box; word-wrap: break-word; outline: 0px; font-size: 12px; vertical-align: baseline; background: transparent;">
						<td style="box-sizing: border-box; word-wrap: break-word; padding: 6px; border: 1px solid rgb(204, 204, 204); outline: 0px; font-size: 12px; vertical-align: baseline; background: transparent;">System.Boolean&nbsp;(C# keyword&nbsp;bool)</td>
						<td style="box-sizing: border-box; word-wrap: break-word; padding: 6px; border: 1px solid rgb(204, 204, 204); outline: 0px; font-size: 12px; vertical-align: baseline; background: transparent;">Not Available</td>
					</tr>
					<tr style="box-sizing: border-box; word-wrap: break-word; outline: 0px; font-size: 12px; vertical-align: baseline; background: transparent;">
						<td style="box-sizing: border-box; word-wrap: break-word; padding: 6px; border: 1px solid rgb(204, 204, 204); outline: 0px; font-size: 12px; vertical-align: baseline; background: transparent;">System.Int32&nbsp;(C# keyword&nbsp;int)</td>
						<td style="box-sizing: border-box; word-wrap: break-word; padding: 6px; border: 1px solid rgb(204, 204, 204); outline: 0px; font-size: 12px; vertical-align: baseline; background: transparent;">Not Available</td>
					</tr>
					<tr style="box-sizing: border-box; word-wrap: break-word; outline: 0px; font-size: 12px; vertical-align: baseline; background: transparent;">
						<td style="box-sizing: border-box; word-wrap: break-word; padding: 6px; border: 1px solid rgb(204, 204, 204); outline: 0px; font-size: 12px; vertical-align: baseline; background: transparent;">System.Double&nbsp;(C# keyword&nbsp;double)</td>
						<td style="box-sizing: border-box; word-wrap: break-word; padding: 6px; border: 1px solid rgb(204, 204, 204); outline: 0px; font-size: 12px; vertical-align: baseline; background: transparent;">float</td>
					</tr>
					<tr style="box-sizing: border-box; word-wrap: break-word; outline: 0px; font-size: 12px; vertical-align: baseline; background: transparent;">
						<td style="box-sizing: border-box; word-wrap: break-word; padding: 6px; border: 1px solid rgb(204, 204, 204); outline: 0px; font-size: 12px; vertical-align: baseline; background: transparent;">System.Single&nbsp;(C# keyword&nbsp;float)</td>
						<td style="box-sizing: border-box; word-wrap: break-word; padding: 6px; border: 1px solid rgb(204, 204, 204); outline: 0px; font-size: 12px; vertical-align: baseline; background: transparent;">float</td>
					</tr>
					<tr style="box-sizing: border-box; word-wrap: break-word; outline: 0px; font-size: 12px; vertical-align: baseline; background: transparent;">
						<td style="box-sizing: border-box; word-wrap: break-word; padding: 6px; border: 1px solid rgb(204, 204, 204); outline: 0px; font-size: 12px; vertical-align: baseline; background: transparent;">System.Windows.Size</td>
						<td style="box-sizing: border-box; word-wrap: break-word; padding: 6px; border: 1px solid rgb(204, 204, 204); outline: 0px; font-size: 12px; vertical-align: baseline; background: transparent;">float2</td>
					</tr>
					<tr style="box-sizing: border-box; word-wrap: break-word; outline: 0px; font-size: 12px; vertical-align: baseline; background: transparent;">
						<td style="box-sizing: border-box; word-wrap: break-word; padding: 6px; border: 1px solid rgb(204, 204, 204); outline: 0px; font-size: 12px; vertical-align: baseline; background: transparent;">System.Windows.Point</td>
						<td style="box-sizing: border-box; word-wrap: break-word; padding: 6px; border: 1px solid rgb(204, 204, 204); outline: 0px; font-size: 12px; vertical-align: baseline; background: transparent;">float2</td>
					</tr>
					<tr style="box-sizing: border-box; word-wrap: break-word; outline: 0px; font-size: 12px; vertical-align: baseline; background: transparent;">
						<td style="box-sizing: border-box; word-wrap: break-word; padding: 6px; border: 1px solid rgb(204, 204, 204); outline: 0px; font-size: 12px; vertical-align: baseline; background: transparent;">System.Windows.Vector</td>
						<td style="box-sizing: border-box; word-wrap: break-word; padding: 6px; border: 1px solid rgb(204, 204, 204); outline: 0px; font-size: 12px; vertical-align: baseline; background: transparent;">float2</td>
					</tr>
					<tr style="box-sizing: border-box; word-wrap: break-word; outline: 0px; font-size: 12px; vertical-align: baseline; background: transparent;">
						<td style="box-sizing: border-box; word-wrap: break-word; padding: 6px; border: 1px solid rgb(204, 204, 204); outline: 0px; font-size: 12px; vertical-align: baseline; background: transparent;">System.Windows.Media.Media3D.Point3D</td>
						<td style="box-sizing: border-box; word-wrap: break-word; padding: 6px; border: 1px solid rgb(204, 204, 204); outline: 0px; font-size: 12px; vertical-align: baseline; background: transparent;">float3</td>
					</tr>
					<tr style="box-sizing: border-box; word-wrap: break-word; outline: 0px; font-size: 12px; vertical-align: baseline; background: transparent;">
						<td style="box-sizing: border-box; word-wrap: break-word; padding: 6px; border: 1px solid rgb(204, 204, 204); outline: 0px; font-size: 12px; vertical-align: baseline; background: transparent;">System.Windows.Media.Media3D.Vector3D</td>
						<td style="box-sizing: border-box; word-wrap: break-word; padding: 6px; border: 1px solid rgb(204, 204, 204); outline: 0px; font-size: 12px; vertical-align: baseline; background: transparent;">float3</td>
					</tr>
					<tr style="box-sizing: border-box; word-wrap: break-word; outline: 0px; font-size: 12px; vertical-align: baseline; background: transparent;">
						<td style="box-sizing: border-box; word-wrap: break-word; padding: 6px; border: 1px solid rgb(204, 204, 204); outline: 0px; font-size: 12px; vertical-align: baseline; background: transparent;">System.Windows.Media.Media3D.Point4D</td>
						<td style="box-sizing: border-box; word-wrap: break-word; padding: 6px; border: 1px solid rgb(204, 204, 204); outline: 0px; font-size: 12px; vertical-align: baseline; background: transparent;">float4</td>
					</tr>
					<tr style="box-sizing: border-box; word-wrap: break-word; outline: 0px; font-size: 12px; vertical-align: baseline; background: transparent;">
						<td style="box-sizing: border-box; word-wrap: break-word; padding: 6px; border: 1px solid rgb(204, 204, 204); outline: 0px; font-size: 12px; vertical-align: baseline; background: transparent;">System.Windows.Media.Color</td>
						<td style="box-sizing: border-box; word-wrap: break-word; padding: 6px; border: 1px solid rgb(204, 204, 204); outline: 0px; font-size: 12px; vertical-align: baseline; background: transparent;">float4</td>
					</tr>
				</tbody>
			</table>
			</td>
		</tr>
	</tbody>
</table>

<div>You need to set up a dependency property for all the values that you want to interact with. There is however one value that you would always have to set up if you want to use the ShaderEffect class, and that is the Input property:</div>

<div>&nbsp;</div>

<div>
<pre lang="vb.net">
 
    Inherits ShaderEffect

    Public Shared ReadOnly InputProperty As DependencyProperty = ShaderEffect.RegisterPixelShaderSamplerProperty(&quot;Input&quot;, GetType(ShaderEffectBase), 0, SamplingMode.NearestNeighbor)

    Protected Sub New()
        Me.UpdateShaderValue(InputProperty)
    End Sub

    &#39;&#39;&#39; &lt;summary&gt;
    &#39;&#39;&#39; Gets, Sets the effect input.
    &#39;&#39;&#39; &lt;/summary&gt;
    Public Property Input() As Brush
        Get
            Return TryCast(Me.GetValue(InputProperty), Brush)
        End Get
        Set(value As Brush)
            Me.SetValue(InputProperty, value)
        End Set
    End Property</pre>

<p>It has a custom build dependency property called <code>RegisterPixelShaderSamplerProperty</code>, which connects to values in the ps file named <code>S0</code>, <code>S1</code> ... <code>Sn</code> where <code>n</code>&nbsp;is the index that is given in the Register of the DependencyProperty, <code>0</code> in the above code. If you have more than one Sampler property (<code>ImageBrushes</code>) a <code>C1</code> will look like the one blow:</p>

<pre lang="vb.net">
 
    Public Shared ReadOnly Input2Property As DependencyProperty = ShaderEffect.RegisterPixelShaderSamplerProperty(&quot;Input2&quot;, GetType(BlendTwoPicturesEffect), 1, SamplingMode.NearestNeighbor)

    Public Property Input2() As Brush
        Get
            Return TryCast(Me.GetValue(Input2Property), Brush)
        End Get
        Set(value As Brush)
            Me.SetValue(Input2Property, value)
        End Set
    End Property</pre>

<p>In the Effect is corresponds to the <code>ImageBrush</code> of the object that is going to be treated by this custom effect class.&nbsp;</p>

<p>The second object type that cane be treated by the <code>ShaderEffect</code> class is the <code>Cn</code> values, given below as it communicates with the value <code>C0</code> in the ps file (of float format):</p>

<pre lang="vb.net">
 
    Public Shared MixInAmountProperty As DependencyProperty = DependencyProperty.Register(&quot;MixInAmount&quot;, GetType(Double), GetType(BlendTwoPicturesEffect),
                    New PropertyMetadata(0.5f, PixelShaderConstantCallback(0)))

    Public Property MixInAmount As Double
        Get
            Return DirectCast(Me.GetValue(MixInAmountProperty), Double)
        End Get
        Set(value As Double)
            Me.SetValue(MixInAmountProperty, value)
        End Set
    End Property</pre>
</div>

<div>Be sure to give the default value (first value) in the <code>PropertyMetaData</code> a proper format, otherwise it wont recognize it as a float number and give you an error. I typically got this when I had 1 as the default value. I had to type <code>1.0f</code> or <code>1.0d</code> to make sure it got recognized.</div>

<div>&nbsp;</div>

<div>The only thing that is missing to have a complete usable custom shader is the constructor:</div>

<pre lang="vb.net">
 
    Sub New()
        Dim s As String = AppDomain.CurrentDomain.BaseDirectory
        PixelShader = New PixelShader With {.UriSource = New Uri(s &amp; &quot;\ShaderFiles\BlendTwoPictures.ps&quot;)}
        Me.UpdateShaderValue(Input2Property)
        Me.UpdateShaderValue(MixInAmountProperty)
    End Sub  </pre>

<div>It basically loading the ps file into the PixelShader, and sends a notification to update the shader effects with the new values. If you ever have the need to update a shader, that is actually possible if you add the code blow to the constructor:</div>

<div>
<pre lang="vb.net">
 
    Public Sub New()
         ...

        AddHandler CompositionTarget.Rendering, AddressOf CompositionTarget_Rendering
    End Sub</pre>
</div>

<div>This will start the function <code>CompositionTarger_Rendering</code> each time the render gets updated on the parent control. You can even adjust the time steps with a short addition of code in the function. This implementation will run once each second (give that the render updates more than once each second):</div>

<pre lang="vb.net">
 
    Dim LastTiumeRendered As Double = 0
    Dim RenderPeriodInMS As Double = 1000
    Private Sub CompositionTarget_Rendering(sender As Object, e As EventArgs)
        Dim rargs As RenderingEventArgs = DirectCast(e, RenderingEventArgs)
        If ((rargs.RenderingTime.TotalMilliseconds - LastTiumeRendered) &gt; RenderPeriodInMS) Then
            ...
            LastTiumeRendered = rargs.RenderingTime.TotalMilliseconds
        End If
    End Sub</pre>

<div>The program made by Rene Schulte&nbsp;uses this approch together with a WritableBitmap to store some random numbers. I used a <a href="http://www.interact-sw.co.uk/iangblog/2006/03/10/wpfrawpixels">BitmapSource</a> directly instead fro convinience.</div>

<div>&nbsp;</div>

<div>And that is really all you need to know to implement shaders into a WPF application. In fact you might even think that it should be possible to generate the base code for any class given that you had the source code for the ps file (usually in fx format). &nbsp;It is a fairly limited number of values that needs to be converted into WPF code, and luckily for me, Walt Ritscher has already done so in his <a href="http://shazzam.codeplex.com/">Shazzam Shader Editor</a>. Unfortunatly it did not compile for me, as it is dependent on a dll that is not included in the download. So I decided to strip out the needed bits and implement the code generator in VB.NET using the CodeDome from Shazzam.</div>

<div>&nbsp;</div>

<div>His implementation is really a tree stage program, first he uses RegEx to find the type of values, the Default value and the range (if it is given) in the fx files. Secondly he stores the found properties in a new class, and from this he generates the code using CodeDom. The RegEx and the storing class is really straigth forward, at least if you use a handy tool like <a href="http://www.codeproject.com/Articles/3669/Expresso-A-Tool-for-Building-and-Testing-Regular-E">Expresso</a> or similar. &nbsp;My problem was that I really coun&#39;t find a good explanation for the CodeDome, so I thought I go through the implementation in some detail.</div>

<div>&nbsp;</div>

<h4>A simple walktrough of CodeDom&nbsp;</h4>

<div>CodeDom is a great tool for generation code, and if you avoid using expressions that could only be found in C# or only in VB.NET you have a generic code generating tool without having to resort to a code converter, and that&#39;s pretty neat. So, I&#39;ll start off from the point that is similar to both code languages in CodeDom. We then start off with the instance <a href="https://msdn.microsoft.com/en-us/library/system.codedom.codecompileunit%28v=vs.110%29.aspx">CodeCompileUnit</a>:</div>

<pre lang="vb.net">
 
   Dim codeGraph As New CodeCompileUnit()</pre>

<div>Having created the blueprint for the class, we usually need to import some namespaces to our class prior to the actual namespace our class will live in, and wrap it in a function:</div>

<div>
<pre lang="vb.net">
 
    Private Function AssignNamespacesToGraph(codeGraph As CodeCompileUnit, namespaceName As String) As CodeNamespace
        &#39; Add imports to the global (unnamed) namespace.
        Dim globalNamespace As New CodeNamespace()
        globalNamespace.[Imports].AddRange({New CodeNamespaceImport(&quot;System&quot;),
                                            New CodeNamespaceImport(&quot;System.Windows&quot;),
                                            New CodeNamespaceImport(&quot;System.Windows.Media&quot;),
                                            New CodeNamespaceImport(&quot;System.Windows.Media.Effects&quot;),
                                            New CodeNamespaceImport(&quot;System.Windows.Media.Media3D&quot;)})

        codeGraph.Namespaces.Add(globalNamespace)

        &#39; Create a named namespace.
        Dim ns As New CodeNamespace(namespaceName)
        codeGraph.Namespaces.Add(ns)
        Return ns
    End Function</pre>
</div>

<div>
<p>The next step is to actually declare the class with the name that we will use:</p>

<pre lang="vb.net">
 
       Dim shader As New CodeTypeDeclaration() With { _
             .Name = shaderModel.GeneratedClassName
         }</pre>

<p>The class now needs to inherit the ShaderEffect class, and that is done by adding it to the the BaseTypes:</p>

<pre lang="vb.net">
 
shader.BaseTypes.Add(New CodeTypeReference(&quot;ShaderEffect&quot;))</pre>

<p>If you wanted to add an interface instead you would do it in exactly the same method:</p>

<pre lang="vb.net">
 
        Dim iequatable As New CodeTypeReference(&quot;IEquatable&quot;, New CodeTypeReference(shader.Name))
        shader.BaseTypes.Add(iequatable)</pre>

<p>Just for the completeness you can implement the INotifiedChange logic as done in the<a href="https://social.msdn.microsoft.com/Forums/vstudio/en-US/515e6ef5-f96e-48c3-94c8-009659a91104/codedom-generate-class-that-implements-interface?forum=netfxbcl"> following example</a>:</p>

<pre lang="vb.net">
 
    Dim myCodeTypeDecl As New CodeTypeDeclaration() With { _
           .Name = &quot;MyClass&quot;
       }
        myCodeTypeDecl.BaseTypes.Add(GetType(System.ComponentModel.INotifyPropertyChanged))

        Dim myEvent As New CodeMemberEvent()
        With myEvent
            .Name = &quot;PropertyChanged&quot;
            .Type = New CodeTypeReference(GetType(System.ComponentModel.PropertyChangedEventHandler))
            .Attributes = MemberAttributes.Public Or MemberAttributes.Final
            .ImplementationTypes.Add(GetType(System.ComponentModel.INotifyPropertyChanged))
        End With

        myCodeTypeDecl.Members.Add(myEvent)

        Dim myMethod As New CodeMemberMethod

        With myMethod
            .Name = &quot;OnPropertyChanged&quot;
            .Parameters.Add(New CodeParameterDeclarationExpression(GetType(String), &quot;pPropName&quot;))
            .ReturnType = New CodeTypeReference(GetType(Void))
            .Statements.Add(New CodeExpressionStatement(
                            New CodeDelegateInvokeExpression(
                                New CodeEventReferenceExpression(
                                    New CodeThisReferenceExpression(), &quot;PropertyChanged&quot;),
                                New CodeExpression() {
                                    New CodeThisReferenceExpression(),
                                    New CodeObjectCreateExpression(GetType(System.ComponentModel.PropertyChangedEventArgs),
                                                                   New CodeArgumentReferenceExpression(&quot;pPropName&quot;))})))

            .Attributes = MemberAttributes.FamilyOrAssembly
        End With

        myCodeTypeDecl.Members.Add(myMethod)

        Dim myProperty As New CodeMemberProperty

        With myProperty
            .Name = &quot;fldItemNr&quot;
            .Attributes = MemberAttributes.Public Or MemberAttributes.Final
            .Type = New CodeTypeReference(GetType(String))
            .SetStatements.Add(New CodeAssignStatement(New CodeVariableReferenceExpression(&quot;m_fldItemNr&quot;), New CodePropertySetValueReferenceExpression))
            .SetStatements.Add(New CodeExpressionStatement(New CodeMethodInvokeExpression(New CodeMethodReferenceExpression(New CodeThisReferenceExpression(), &quot;OnPropertyChanged&quot;), New CodeExpression() {New CodePrimitiveExpression(&quot;fldItemNr&quot;)})))
            .GetStatements.Add(New CodeMethodReturnStatement(New CodeVariableReferenceExpression(&quot;m_fldItemNr&quot;)))
        End With

        myCodeTypeDecl.Members.Add(myProperty)</pre>

<p>Back to the construction of the ps file ShaderEffect wrapper. We also need to implement the ps file in the constructor of the class, so we add logic for the creation of public constructor:</p>

<pre lang="vb.net">
 
 Dim constructor As New CodeConstructor() With { _
             .Attributes = MemberAttributes.[Public]
        }</pre>

<p>We also need to create a relative Uri path to the location of the ps file, and set this Uri path to the PixelShader that is inherited from the ShaderEffect class:</p>

<pre lang="vb.net">
 
        Dim shaderRelativeUri As String = [String].Format(&quot;/{0};component/{1}.ps&quot;, shaderModel.GeneratedNamespace, shaderModel.GeneratedClassName)

        Dim CreateUri As New CodeObjectCreateExpression
        CreateUri.CreateType = New CodeTypeReference(&quot;Uri&quot;)
        CreateUri.Parameters.AddRange({New CodePrimitiveExpression(shaderRelativeUri), New CodeFieldReferenceExpression(New CodeTypeReferenceExpression(&quot;UriKind&quot;), &quot;Relative&quot;)})

        Dim ConnectUriSource As New CodeAssignStatement With {
                .Left = New CodeFieldReferenceExpression(New CodeThisReferenceExpression, &quot;PixelShader.UriSource&quot;),
                .Right = CreateUri}</pre>

<p>Then we need to create a new instance of a PixelShader and add the code above to the constructor, and we also add an empty line at the end for some space:</p>

<pre lang="vb.net">
 
        constructor.Statements.AddRange({New CodeAssignStatement() With {.Left = New CodePropertyReferenceExpression(New CodeThisReferenceExpression(), &quot;PixelShader&quot;),
                                                                         .Right = New CodeObjectCreateExpression(New CodeTypeReference(&quot;PixelShader&quot;))},
                                         ConnectUriSource,
                                         New CodeSnippetStatement(&quot;&quot;)})</pre>

<p>In the constructor we also need to update the shader values by the command:</p>

<pre lang="vb.net">
 
        Dim result As New CodeMethodInvokeExpression() With { _
             .Method = New CodeMethodReferenceExpression(New CodeThisReferenceExpression(), &quot;UpdateShaderValue&quot;)
        }

        result.Parameters.Add(New CodeVariableReferenceExpression(propertyName &amp; &quot;Property&quot;))</pre>

<p>This is done in a function as we need to do this for all the properties found in the ps file.</p>

<p>The creation of <code>DependencyProperties</code> is done in a function, please not that it only supports values of <code>Cn</code> as it communicates through the <code>PixelShaderConstantCallback</code>.&nbsp;</p>

<pre lang="vb.net">
 
    Private Function CreateShaderRegisterDependencyProperty(shaderModel As ShaderModel, register As ShaderModelConstantRegister) As CodeMemberField

        Dim RegisterDependencyProperty As New CodeMethodInvokeExpression
        Dim RegisterMethod As New CodeMethodReferenceExpression
        RegisterMethod.TargetObject = New CodeTypeReferenceExpression(&quot;DependencyProperty&quot;)
        RegisterMethod.MethodName = &quot;Register&quot;

        RegisterDependencyProperty.Method = RegisterMethod

        Dim PropertyMetadataFunction As New CodeObjectCreateExpression
        PropertyMetadataFunction.CreateType = New CodeTypeReference(&quot;PropertyMetadata&quot;)
        PropertyMetadataFunction.Parameters.Add(CreateDefaultValue(register.DefaultValue))

        Dim PropertyMetadataCallback As New CodeMethodInvokeExpression
        PropertyMetadataCallback.Method = New CodeMethodReferenceExpression(Nothing, &quot;PixelShaderConstantCallback&quot;)
        PropertyMetadataCallback.Parameters.Add(New CodePrimitiveExpression(register.RegisterNumber))
        PropertyMetadataFunction.Parameters.Add(PropertyMetadataCallback)

        RegisterDependencyProperty.Parameters.AddRange({New CodePrimitiveExpression(register.RegisterName), New CodeTypeOfExpression(register.RegisterType), New CodeTypeOfExpression(shaderModel.GeneratedClassName), PropertyMetadataFunction})

        Dim InitiateDependencyProperty As New CodeMemberField
        InitiateDependencyProperty.Type = New CodeTypeReference(&quot;DependencyProperty&quot;)
        InitiateDependencyProperty.Name = String.Format(&quot;{0}Property&quot;, register.RegisterName)
        InitiateDependencyProperty.Attributes = MemberAttributes.Public Or MemberAttributes.Static
        InitiateDependencyProperty.InitExpression = RegisterDependencyProperty

        Return InitiateDependencyProperty
    End Function</pre>

<p>To communicate with the sample register (<code>Sn</code>) you need a slightly different (and shorter) code:</p>

<pre lang="vb.net">
 
    Private Function CreateSamplerDependencyProperty(className As String, propertyName As String, ByVal RegisterNumber As Integer) As CodeMemberField

        Dim RegisterDependencyProperty As New CodeMethodInvokeExpression
        Dim RegisterMethod As New CodeMethodReferenceExpression
        RegisterMethod.TargetObject = New CodeTypeReferenceExpression(&quot;ShaderEffect&quot;)
        RegisterMethod.MethodName = &quot;RegisterPixelShaderSamplerProperty&quot;

        RegisterDependencyProperty.Method = RegisterMethod
        RegisterDependencyProperty.Parameters.AddRange({New CodePrimitiveExpression(propertyName), New CodeTypeOfExpression(className), New CodePrimitiveExpression(RegisterNumber)})

        Dim result As New CodeMemberField
        result.Type = New CodeTypeReference(&quot;DependencyProperty&quot;)
        result.Name = String.Format(&quot;{0}Property&quot;, propertyName)
        result.Attributes = MemberAttributes.Public Or MemberAttributes.Static
        result.InitExpression = RegisterDependencyProperty

        Return result
    End Function</pre>

<p>Now its just a matter of looping trough all the properties that one found in the fx file, and generate and add all the code:</p>

<pre lang="vb.net">
 
        &#39; Add a dependency property and a CLR property for each of the shader&#39;s register variables
        For Each register As ShaderModelConstantRegister In shaderModel.Registers
            If register.GPURegisterType.ToString.ToLower = &quot;c&quot; Then
                shader.Members.Add(CreateShaderRegisterDependencyProperty(shaderModel, register))
                shader.Members.Add(CreateCLRProperty(register.RegisterName, register.RegisterType, register.Description))
            Else
                shader.Members.Add(CreateSamplerDependencyProperty(shaderModel.GeneratedClassName, register.RegisterName, register.GPURegisterNumber))
                shader.Members.Add(CreateCLRProperty(register.RegisterName, GetType(Brush), Nothing))
            End If
        Next</pre>

<p>All the code that is needed to communicate with the ps file through ShaderEffect class in WPF is now included. Creating the VB or C# code is now really simple. This is indeed one of the true magic things with using CodeDom.</p>

<pre lang="vb.net">
 
    Private Function GenerateCode(provider As CodeDomProvider, compileUnit As CodeCompileUnit) As String
        &#39; Generate source code using the code generator.
        Using writer As New StringWriter()
            Dim indentString As String = &quot;&quot; 
            Dim options As New CodeGeneratorOptions() With { _
                 .IndentString = indentString, _
                 .BlankLinesBetweenMembers = True _
            }
            provider.GenerateCodeFromCompileUnit(compileUnit, writer, options)
            Dim text As String = writer.ToString()
            &#39; Fix up code: make static DP fields readonly, and use triple-slash or triple-quote comments for XML doc comments.
            If provider.FileExtension = &quot;cs&quot; Then
                text = text.Replace(&quot;public static DependencyProperty&quot;, &quot;public static readonly DependencyProperty&quot;)
                text = Regex.Replace(text, &quot;// &lt;(?!/?auto-generated)&quot;, &quot;/// &lt;&quot;)
            ElseIf provider.FileExtension = &quot;vb&quot; Then
                text = text.Replace(&quot;Public Shared &quot;, &quot;Public Shared ReadOnly &quot;)
                text = text.Replace(&quot;&#39;&lt;&quot;, &quot;&#39;&#39;&#39;&lt;&quot;)
            End If
            Return text
        End Using
    End Function</pre>

<p>The CodeDomProvider can either be in VB.NET:</p>

<pre>
 
         Dim provider As New Microsoft.VisualBasic.VBCodeProvider()</pre>

<p>or C#:</p>

<pre lang="vb.net">
 
         Dim provider As New Microsoft.CSharp.CSharpCodeProvider()</pre>

<p>Now you can quite simply provide the user with the code that he prefers.</p>

<h3>Some advanced tips and tricks</h3>

<h4>Store a picture of the Effect</h4>

<p>To actually store the control with the applied effect, you will have to result to RenderTargetBitmap function. This is a bit upsetting perhaps, as RenderTargetBitmap uses the CPU to proccess the UIElement. You can also get into trouble if you don&#39;t do it correctly as shown by <a href="http://blogs.msdn.com/b/jaimer/archive/2009/07/03/rendertargetbitmap-tips.aspx">Jamie Rodriguez in his blog</a>. The code shown below is originally written by Adam Smith though.</p>

<pre lang="vb.net">
 
    Private Shared Function CaptureScreen(target As Visual, Optional dpiX As Double = 96, Optional dpiY As Double = 96) As BitmapSource
        If target Is Nothing Then
            Return Nothing
        End If
        Dim bounds As Rect = VisualTreeHelper.GetDescendantBounds(target)
        Dim rtb As New RenderTargetBitmap(CInt(bounds.Width * dpiX / 96.0), CInt(bounds.Height * dpiY / 96.0), dpiX, dpiY, PixelFormats.Pbgra32)
        Dim dv As New DrawingVisual()
        Using ctx As DrawingContext = dv.RenderOpen()
            Dim vb As New VisualBrush(target)
            ctx.DrawRectangle(vb, Nothing, New Rect(New Point(), bounds.Size))
        End Using
        rtb.Render(dv)
        Return rtb
    End Function</pre>

<h4>Apply multiple effects to one control</h4>

<p>When the old (and now outdated function) BitmapEffects were released they came with something called BitmapEffectGroup, which allowed you to apply several effects on one control. However, when the new Effect class that used the GPU instead of the CPU was created, the EffectGroup control was considered too difficult to implement directly.&nbsp;</p>

<p>So if you still want to implement it there are two ways of doing it. The first one, suggested by Greg Schuster <a href="http://blogs.msdn.com/b/greg_schechter/archive/2008/05/12/using-effect-in-wpf-part-2.aspx">here</a>, is to simply wrap a Border around the element you which to add an effect to, and add the second effect to the border as shown below.</p>

<pre lang="html">
 
        &lt;Border&gt;
                        &lt;Border.Effect&gt;
                            &lt;local:GaussianEffect/&gt;
                        &lt;/Border.Effect&gt;
                        &lt;Image&gt;
                            &lt;Image.Effect&gt;
                                &lt;local:ScratchedShader&gt;&lt;/local:ScratchedShader&gt;
                            &lt;/Image.Effect&gt;
                        &lt;/Image&gt;
                    &lt;/Border&gt;</pre>

<p>Its fairly straight forward to implement in WPF without doing anything to the fx files.</p>

<p>There is however a better option, at least if you consider the computation time. All the fx files have an entry point function, which means that all of the functions of the different fx files could be united in one new fx file and compiled. You would of course also need to have the variables that WPF gives the input to the ps file with also.</p>

<p>I seems that the <a href="http://stackoverflow.com/questions/14090060/use-multiple-pixel-shaders">XNA framework</a> have some means to load the ps files directly, but that is beond the scope of this article.</p>

<h4>Apply effects only to a part of the control</h4>

<p>A question that arises quite often is to apply the Effect on a part of an Image or Control. One way to do this is to call the <code>Image.Clip</code> and add an effect to that.&nbsp;</p>

<pre lang="html">
 
             &lt;Rectangle VerticalAlignment=&quot;Top&quot; HorizontalAlignment=&quot;Left&quot; x:Name=&quot;BoundImageRect&quot;  Height=&quot;50&quot; Width=&quot;50&quot; Panel.ZIndex=&quot;4&quot; Stroke=&quot;Black&quot; Fill=&quot;Transparent&quot;  StrokeThickness=&quot;2&quot; MouseDown=&quot;BoundImageRect_MouseDown&quot; MouseMove=&quot;BoundImageRect_MouseMove&quot; MouseUp=&quot;BoundImageRect_MouseUp&quot; &gt;
                            &lt;Rectangle.RenderTransform&gt;
                                &lt;TranslateTransform x:Name=&quot;Trans&quot; X=&quot;0&quot; Y=&quot;0&quot;&gt;&lt;/TranslateTransform&gt;
                            &lt;/Rectangle.RenderTransform&gt;
                        &lt;/Rectangle&gt;
                        &lt;Image  VerticalAlignment=&quot;Top&quot; HorizontalAlignment=&quot;Left&quot;  Width=&quot;Auto&quot; Height=&quot;356&quot; Source=&quot;{Binding ElementName=Img, Path=Source }&quot; Panel.ZIndex=&quot;3&quot;&gt;
                            &lt;Image.Clip&gt;
                                &lt;RectangleGeometry RadiusX=&quot;{Binding ElementName=BoundImageRect,Path=RadiusX}&quot; RadiusY=&quot;{Binding ElementName=BoundImageRect,Path=RadiusY}&quot; &gt;
                                    &lt;RectangleGeometry.Rect&gt;
                                        &lt;MultiBinding Converter=&quot;{StaticResource convertRect}&quot;&gt;
                                            &lt;Binding ElementName=&quot;BoundImageRect&quot; Path=&quot;Width&quot;/&gt;
                                            &lt;Binding ElementName=&quot;BoundImageRect&quot; Path=&quot;Height&quot;/&gt;
                                            &lt;Binding ElementName=&quot;Trans&quot; Path=&quot;X&quot;/&gt;
                                            &lt;Binding ElementName=&quot;Trans&quot; Path=&quot;Y&quot;/&gt;
                                        &lt;/MultiBinding&gt;
                                    &lt;/RectangleGeometry.Rect&gt;
                                &lt;/RectangleGeometry&gt;
                            &lt;/Image.Clip&gt;
                            &lt;Image.Effect&gt;
                                &lt;local:GaussianEffect&gt;&lt;/local:GaussianEffect&gt;
                            &lt;/Image.Effect&gt;
                        &lt;/Image&gt;</pre>

<p>However I actually experienced a memory leak while using this, so It might be a bit unstable.&nbsp;</p>

<p>There are two other ways of chopping an element up. One is by adding an effect to a visual:</p>

<pre lang="vb.net">
 
Public Class CoolDrawing
    Inherits FrameworkElement

    Implements System.ComponentModel.INotifyPropertyChanged

    &#39; Create a collection of child visual objects.
    Private _children As VisualCollection

    Public Sub New()
        _children = New VisualCollection(Me)

        Dim VisualImage As DrawingVisual
        VisualImage = CreateDrawingVisualCircle()
        VisualImage.Effect = New GaussianEffect
        _children.Add(VisualImage)

    End Sub</pre>

<p>You can apply different effects on different DraingVisuals as you see fit.&nbsp;</p>

<p>And as always there is a possibility to have the fx file itself only work on a small section, as is the case with the magnifier glass that is included. You don not have the opportunity (at least not without considerable work) to manipulate particular sections of the image with this approach.&nbsp;</p>

<p>&nbsp;</p>

<h2>Points of interest</h2>

<p>This wraps up part 1 of the series of adventures into shader effects, the beginning of the journey into shader effects, as this light Shazzam Editor tool will function as a toolbox for testing and debugging shader tools that you have created yourself.</p>

<p>I would also like to point out some of the references used in this article:</p>

<p><a href="https://shazzam.codeplex.com/">Shazzam Shader Editor </a>- a fantastic tool written by Walt Ritscher&nbsp;(program wont run as it is though)</p>

<p><a href="http://www.amazon.com/HLSL-Pixel-Shaders-XAML-Developers-ebook/dp/B008IGILUE/ref=asap_bc?ie=UTF8">HLSL and Pixel Shaders for XAML Developers</a> by Walt Ritscher</p>

<p>The blog&nbsp;<a href="http://kodierer.blogspot.no/">Kodierer [Coder]</a> by&nbsp;Rene Schulte, an MVP. He has some brilliant shadereffects articles for silverlight.&nbsp;</p>
</div>

<h4>Examples of shaders in action</h4>

<ul>
	<li><a href="https://www.shadertoy.com/">https://www.shadertoy.com/</a></li>
	<li><a href="http://www.codeproject.com/Articles/36722/Create-Reflection-Shader-in-Silverlight">http://www.codeproject.com/Articles/36722/Create-Reflection-Shader-in-Silverlight</a></li>
	<li><a href="http://www.codeproject.com/Articles/226547/Mandelbrot-Set-with-PixelShader-in-WPF">http://www.codeproject.com/Articles/226547/Mandelbrot-Set-with-PixelShader-in-WPF</a></li>
	<li><a href="http://www.codeproject.com/Articles/71617/Getting-Started-with-Shader-Effects-in-WPF">http://www.codeproject.com/Articles/71617/Getting-Started-with-Shader-Effects-in-WPF</a></li>
	<li><a href="http://www.codeproject.com/Articles/89337/GLSL-Shader-for-Interpolating-Two-Textures">http://www.codeproject.com/Articles/89337/GLSL-Shader-for-Interpolating-Two-Textures</a></li>
	<li><a href="http://www.codeproject.com/Articles/94817/Pixel-Shader-for-Edge-Detection-and-Cartoon-Effect">http://www.codeproject.com/Articles/94817/Pixel-Shader-for-Edge-Detection-and-Cartoon-Effect</a></li>
	<li>http://blogs.microsoft.co.il/tamir/2008/05/23/brightness-and-contrast-manipulation-in-wpf-35-sp1/</li>
	<li>http://khason.net/blog/hlsl-pixel-shader-effects-tutorial/</li>
	<li>http://www.rastertek.com/dx10tut32.html</li>
	<li>http://www.geeks3d.com/20101228/shader-library-frosted-glass-post-processing-shader-glsl/</li>
	<li>&nbsp;</li>
</ul>

<h4>Beond fanzy pictures</h4>

<ul>
	<li><a href="http://gamedev.stackexchange.com/questions/59619/gpgpu-programming-using-hlsl-and-xna">http://gamedev.stackexchange.com/questions/59619/gpgpu-programming-using-hlsl-and-xna</a></li>
</ul>
